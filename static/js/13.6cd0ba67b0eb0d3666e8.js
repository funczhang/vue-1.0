webpackJsonp([13],{120:function(s,a,t){var v=t(20)(null,t(150),null,null);s.exports=v.exports},150:function(s,a){s.exports={render:function(){var s=this,a=s.$createElement;s._self._c;return s._m(0)},staticRenderFns:[function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("section",[t("h2",[s._v("ECMAScript 6/7")]),s._v(" "),t("h3",[s._v("1.简介")]),s._v(" "),t("p",[s._v("  ECMAScript 6.0（以下简称 ES6）是 "),t("code",[s._v("JavaScript")]),s._v(" 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得"),t("code",[s._v("JavaScript")]),s._v("语言可以用来编写复杂的大型应用程序，成为企业级开发语言。")]),s._v(" "),t("p",[s._v("  ECMAScript 2016(以下简称ES7)是最新的"),t("code",[s._v("JavaScript")]),s._v("标准库，于2016年发布，引入了"),t("code",[s._v("async/await")]),s._v("等新特性。")]),s._v(" "),t("h3",[s._v("2.新规范")]),s._v(" "),t("h4",[s._v("2.1 声明")]),s._v(" "),t("h4",[s._v("2.1.1 import引入")]),s._v(" "),t("p",[s._v("  ES6之前已经出现了js模块加载的方案，最主要的是CommonJS和AMD规范。commonjs主要应用于服务器，实现同步加载，如nodejs。AMD规范应用于浏览器，如requirejs，为异步加载。同时还有CMD规范，为同步加载方案如seaJS。")]),s._v(" "),t("p",[s._v("  ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-comment"},[s._v("// CommonJS的写法")]),s._v("\n"),t("span",{staticClass:"hljs-built_in"},[s._v("require")]),s._v("("),t("span",{staticClass:"hljs-string"},[s._v("'system.global/shim'")]),s._v(")();\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// ES6模块的写法")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("import")]),s._v(" shim "),t("span",{staticClass:"hljs-keyword"},[s._v("from")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'system.global/shim'")]),s._v("; \nshim();\n\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// CommonJS的写法")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" global = "),t("span",{staticClass:"hljs-built_in"},[s._v("require")]),s._v("("),t("span",{staticClass:"hljs-string"},[s._v("'system.global'")]),s._v(")();\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// ES6模块的写法")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("import")]),s._v(" getGlobal "),t("span",{staticClass:"hljs-keyword"},[s._v("from")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'system.global'")]),s._v(";\n"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" global = getGlobal();\n")])]),s._v(" "),t("p",[s._v("  export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口")]),s._v(" "),t("p",[s._v("  import用于在一个模块中加载另一个含有export接口的模块。")]),s._v(" "),t("p",[s._v("  也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-comment"},[s._v("// a.js")]),s._v("\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" sex="),t("span",{staticClass:"hljs-string"},[s._v('"boy"')]),s._v(";\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" echo="),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(")")]),s._v("{\n　　"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(value)\n}\n"),t("span",{staticClass:"hljs-keyword"},[s._v("export")]),s._v(" {sex,echo}  \n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// b.js")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("import")]),s._v(" {sex,echo} "),t("span",{staticClass:"hljs-keyword"},[s._v("from")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v('"./a.js"')]),s._v(" \n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(sex)   "),t("span",{staticClass:"hljs-comment"},[s._v("// boy")]),s._v("\necho(sex) "),t("span",{staticClass:"hljs-comment"},[s._v("// boy")]),s._v("\n")])]),s._v(" "),t("h4",[s._v("2.1.2 变量声明")]),s._v(" "),t("p",[s._v("  ES6新增了"),t("code",[s._v("let")]),s._v("命令，用来声明变量。它的用法类似于"),t("code",[s._v("var")]),s._v("，但是所声明的变量，只在"),t("code",[s._v("let")]),s._v("命令所在的代码块内有效。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" a = "),t("span",{staticClass:"hljs-number"},[s._v("10")]),s._v(";\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" b = "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";\n}\n\na "),t("span",{staticClass:"hljs-comment"},[s._v("// ReferenceError: a is not defined.")]),s._v("\nb "),t("span",{staticClass:"hljs-comment"},[s._v("// 1")]),s._v("\n")])]),s._v(" "),t("p",[s._v("  上面代码中，使用"),t("code",[s._v("let")]),s._v("声明的"),t("code",[s._v("a")]),s._v("只在所属代码块中生效，在代码块之外调用"),t("code",[s._v("a")]),s._v("就会出现错误，而使用"),t("code",[s._v("var")]),s._v("声明的"),t("code",[s._v("b")]),s._v("则返回了正确的值。使用"),t("code",[s._v("let")]),s._v("声明的参数，不会污染代码块之外的空间，保证了不同模块的独立性，提供了块级作用域的建立和操作方法。")]),s._v(" "),t("p",[t("code",[s._v("const")]),s._v("命令在ES6中一般用来声明一个常量，并在声明的同时完成初始化，一旦声明完成，不可改变。")]),s._v(" "),t("p",[t("code",[s._v("const")]),s._v("的作用域和"),t("code",[s._v("let")]),s._v("相同，只在当前代码块内有效。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" PI = "),t("span",{staticClass:"hljs-number"},[s._v("3.1415")]),s._v(";\nPI "),t("span",{staticClass:"hljs-comment"},[s._v("// 3.1415")]),s._v("\n\nPI = "),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(";\n"),t("span",{staticClass:"hljs-comment"},[s._v("// TypeError: Assignment to constant variable.")]),s._v("\n")])]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" foo;\n")])]),s._v(" "),t("p",[s._v("  以上两段代码都会报错，因为"),t("code",[s._v("const")]),s._v("在声明变量时必须给变量赋值完成初始化，且之后不可改变。")]),s._v(" "),t("p",[t("code",[s._v("const")]),s._v("声明的本质在于把一个变量固定指向一个不变的内存地址并赋值，也就是一个定指针，但是指向的数据结构是否会变化是完全不可控的。")]),s._v(" "),t("h4",[s._v("2.2 同步异步")]),s._v(" "),t("p",[s._v("  ES7对于异步推出的新特性是"),t("code",[s._v("async")]),s._v("，它允许以同步的方式编写异步代码，而不需要回调或"),t("code",[s._v("Promise")]),s._v("的复杂语法。")]),s._v(" "),t("h4",[s._v("2.2.1 Promise")]),s._v(" "),t("p",[s._v("  ES6 原生提供了 "),t("code",[s._v("Promise")]),s._v(" 对象。")]),s._v(" "),t("p",[s._v("  所谓 "),t("code",[s._v("Promise")]),s._v("，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。")]),s._v(" "),t("p",[t("code",[s._v("Promise")]),s._v(" 对象有以下两个特点。")]),s._v(" "),t("p",[s._v("  （1）对象的状态不受外界影响。"),t("code",[s._v("Promise")]),s._v(" 对象代表一个异步操作，有三种状态："),t("code",[s._v("Pending")]),s._v("（进行中）、"),t("code",[s._v("Resolved")]),s._v("（已完成，又称 "),t("code",[s._v("Fulfilled")]),s._v("）和 "),t("code",[s._v("Rejected")]),s._v("（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 "),t("code",[s._v("Promise")]),s._v(" 这个名字的由来，它的英语意思就是"),t("code",[s._v("「承诺」")]),s._v("，表示其他手段无法改变。")]),s._v(" "),t("p",[s._v("  （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。"),t("code",[s._v("Promise")]),s._v(" 对象的状态改变，只有两种可能：从 "),t("code",[s._v("Pending")]),s._v(" 变为 "),t("code",[s._v("Resolved")]),s._v(" 和从 "),t("code",[s._v("Pending")]),s._v(" 变为 "),t("code",[s._v("Rejected")]),s._v("。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 "),t("code",[s._v("Promise")]),s._v(" 对象添加回调函数，也会立即得到这个结果。这与事件（"),t("code",[s._v("Event")]),s._v("）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。")]),s._v(" "),t("p",[s._v("  有了 "),t("code",[s._v("Promise")]),s._v(" 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，"),t("code",[s._v("Promise")]),s._v(" 对象提供统一的接口，使得控制异步操作更加容易。")]),s._v(" "),t("p",[t("code",[s._v("Promise")]),s._v(" 也有一些缺点。首先，无法取消 "),t("code",[s._v("Promise")]),s._v("，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，"),t("code",[s._v("Promise")]),s._v(" 内部抛出的错误，不会反应到外部。第三，当处于 "),t("code",[s._v("Pending")]),s._v(" 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" promise = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") ")]),s._v("{\n "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-comment"},[s._v("/* 异步操作成功 */")]),s._v("){\n resolve(value);\n } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n reject(error);\n }\n});\n\npromise.then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(") ")]),s._v("{\n "),t("span",{staticClass:"hljs-comment"},[s._v("// success")]),s._v("\n}, "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(") ")]),s._v("{\n "),t("span",{staticClass:"hljs-comment"},[s._v("// failure")]),s._v("\n});\n")])]),s._v(" "),t("p",[t("code",[s._v("promises")]),s._v(" 的用途在于给予我们以前的 "),t("code",[s._v("return")]),s._v(" 与 "),t("code",[s._v("throw")]),s._v("，每个 "),t("code",[s._v("Promise")]),s._v(" 都会提供一个 "),t("code",[s._v("then()")]),s._v(" 函数，和一个 "),t("code",[s._v("catch()")]),s._v("，实际上是 "),t("code",[s._v("then(null, ...)")]),s._v(" 函数，所以我们可以：")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" 另一个 promise\n"),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" 一个同步的值 (或者 "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(")\n"),t("span",{staticClass:"hljs-keyword"},[s._v("throw")]),s._v(" 一个同步异常 "),t("span",{staticClass:"hljs-string"},[s._v("` throw new Eror('');`")]),s._v("\n")])]),s._v(" "),t("h4",[s._v("2.2.2 Async/Await")]),s._v(" "),t("p",[t("code",[s._v("Async/Await")]),s._v("应该是目前最简单的异步方案了：")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" sleep = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("time")]),s._v(") ")]),s._v("{\n     "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") ")]),s._v("{\n         setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n             "),t("span",{staticClass:"hljs-comment"},[s._v("// 返回 ‘ok’")]),s._v("\n             resolve("),t("span",{staticClass:"hljs-string"},[s._v("'ok'")]),s._v(");\n         }, time);\n     })\n };\n \n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" start = "),t("span",{staticClass:"hljs-keyword"},[s._v("async")]),s._v(" "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n       "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" result = "),t("span",{staticClass:"hljs-keyword"},[s._v("await")]),s._v(" sleep("),t("span",{staticClass:"hljs-number"},[s._v("3000")]),s._v(");\n       "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(result); "),t("span",{staticClass:"hljs-comment"},[s._v("// 收到 ‘ok’")]),s._v("\n};\n")])]),s._v(" "),t("p",[t("code",[s._v("async")]),s._v(" 表示这是一个"),t("code",[s._v("async")]),s._v("函数，"),t("code",[s._v("await")]),s._v("只能用在这个函数里面。")]),s._v(" "),t("p",[t("code",[s._v("await")]),s._v(" 表示在这里等待"),t("code",[s._v("promise")]),s._v("返回结果了，再继续执行。")]),s._v(" "),t("p",[t("code",[s._v("await")]),s._v(" 后面跟着的应该是一个"),t("code",[s._v("promise")]),s._v("对象")]),s._v(" "),t("p",[s._v("  既然"),t("code",[s._v(".then(..)")]),s._v("不用写了，那么"),t("code",[s._v(".catch(..)")]),s._v("也不用写，可以直接用标准的"),t("code",[s._v("try catch")]),s._v("语法捕捉错误")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" sleep = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("time")]),s._v(") ")]),s._v("{\n     "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") ")]),s._v("{\n         setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n             "),t("span",{staticClass:"hljs-comment"},[s._v("// 模拟出错了，返回 ‘error’")]),s._v("\n             reject("),t("span",{staticClass:"hljs-string"},[s._v("'error'")]),s._v(");\n         }, time);\n     })\n };\n \n "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" start = "),t("span",{staticClass:"hljs-keyword"},[s._v("async")]),s._v(" "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n     "),t("span",{staticClass:"hljs-keyword"},[s._v("try")]),s._v(" {\n         "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-string"},[s._v("'start'")]),s._v(");\n         "),t("span",{staticClass:"hljs-keyword"},[s._v("await")]),s._v(" sleep("),t("span",{staticClass:"hljs-number"},[s._v("3000")]),s._v("); "),t("span",{staticClass:"hljs-comment"},[s._v("// 这里得到了一个返回错误")]),s._v("\n         \n         "),t("span",{staticClass:"hljs-comment"},[s._v("// 所以以下代码不会被执行了")]),s._v("\n         "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-string"},[s._v("'end'")]),s._v(");\n     } "),t("span",{staticClass:"hljs-keyword"},[s._v("catch")]),s._v(" (err) {\n         "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(err); "),t("span",{staticClass:"hljs-comment"},[s._v("// 这里捕捉到错误 `error`")]),s._v("\n     }\n };\n")])]),s._v(" "),t("h4",[s._v("2.3 类与继承")]),s._v(" "),t("h4",[s._v("2.3.1 类（Class）")]),s._v(" "),t("h4",[s._v("1.基本语法")]),s._v(" "),t("p",[s._v("  JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Point")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("x, y")]),s._v(") ")]),s._v("{\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x = x;\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".y = y;\n}\n\nPoint.prototype.toString = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'('")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x + "),t("span",{staticClass:"hljs-string"},[s._v("', '")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".y + "),t("span",{staticClass:"hljs-string"},[s._v("')'")]),s._v(";\n};\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" p = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Point("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(");\n")])]),s._v(" "),t("p",[s._v("  ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-comment"},[s._v("//定义类")]),s._v("\n"),t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Point")]),s._v(" ")]),s._v("{\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("(x, y) {    "),t("span",{staticClass:"hljs-comment"},[s._v("//constructor 构造方法")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x = x;\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".y = y;\n    }\n\n    toString() {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'('")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x + "),t("span",{staticClass:"hljs-string"},[s._v("', '")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".y + "),t("span",{staticClass:"hljs-string"},[s._v("')'")]),s._v(";\n    }\n}\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" p = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Point("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(");\n")])]),s._v(" "),t("p",[s._v("  构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都还是定义在类的prototype属性上面。")]),s._v(" "),t("h4",[s._v("2.constructor方法")]),s._v(" "),t("p",[s._v("  constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。")]),s._v(" "),t("h4",[s._v("2.3.2继承（Extends）")]),s._v(" "),t("p",[s._v("  Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。")]),s._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("ColorPoint")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("extends")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Point")]),s._v(" ")]),s._v("{\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("(x, y, color) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("super")]),s._v("(x, y); "),t("span",{staticClass:"hljs-comment"},[s._v("// 调用父类的constructor(x, y)")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color = color;\n    }\n\n    toString() {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color + "),t("span",{staticClass:"hljs-string"},[s._v("' '")]),s._v(" + "),t("span",{staticClass:"hljs-keyword"},[s._v("super")]),s._v(".toString(); "),t("span",{staticClass:"hljs-comment"},[s._v("// 调用父类的toString()")]),s._v("\n    }\n}\n")])]),s._v(" "),t("p",[s._v("  上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。")]),s._v(" "),t("p",[s._v("  子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。")])])}]}},72:function(s,a,t){s.exports=t(120)}});