webpackJsonp([5],{128:function(t,s,a){var n=a(20)(null,a(145),null,null);t.exports=n.exports},145:function(t,s){t.exports={render:function(){var t=this,s=t.$createElement;t._self._c;return t._m(0)},staticRenderFns:[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("section",[a("h2",[t._v("Vue 全家桶")]),t._v(" "),a("h3",[t._v("1.什么是全家桶")]),t._v(" "),a("p",[t._v("  Vue专注于视图层与数据层的关系处理，在数据与视图的实时反馈上非常强大，但在数据处理以及状态管理方面，Vue并没有特别强势的体现，所以Vue官方开发了许多与之配套的工具，可以更好地弥补Vue在状态管理层面的不足，这些工具加上Vue统称为 "),a("strong",[t._v("Vue全家桶")]),t._v(" ，这里介绍几种常用并且功能强大的Vue工具。")]),t._v(" "),a("br"),t._v(" "),a("h3",[t._v("2.状态管理工具Vuex")]),t._v(" "),a("h4",[t._v("2.1 Vuex 是什么")]),t._v(" "),a("p",[t._v("  Vuex 是一个专为 Vue.js 应用程序开发的 "),a("strong",[t._v("状态管理模式")]),t._v(" 。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 "),a("a",{attrs:{href:"https://github.com/vuejs/vue-devtools"}},[t._v("devtools extension")]),t._v("，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。")]),t._v(" "),a("h4",[t._v("2.2 Vuex核心概念")]),t._v(" "),a("p",[t._v("  Vuex核心概念包含5个模块，分别是 "),a("code",[t._v("State")]),t._v(" 、"),a("code",[t._v("Getters")]),t._v(" 、"),a("code",[t._v("Mutations")]),t._v(" 、"),a("code",[t._v("Actions")]),t._v(" 、"),a("code",[t._v("Modules")]),t._v("，这5个模块构成了整个Vuex的状态管理模式。合理使用Vuex可以更好地管理应用的状态，监听数据的变化，使用户有更好地交互体验。")]),t._v(" "),a("h4",[t._v("2.2.1 State")]),t._v(" "),a("p",[t._v("  Vuex 使用 单一状态树 —— 是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个 "),a("strong",[t._v("唯一数据源")]),t._v(" 而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。")]),t._v(" "),a("h4",[t._v("2.2.2 Getters")]),t._v(" "),a("p",[t._v("  Getters可以理解为获取状态数state的封装方法，通过调用getters，可以获取到对状态数进行一定操作后的返回值。")]),t._v(" "),a("h4",[t._v("2.2.3 Mutations")]),t._v(" "),a("p",[t._v("  更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：")]),t._v(" "),a("pre",[a("code",{staticClass:"language-javascript"},[t._v("\n"),a("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" store = "),a("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" Vuex.Store({\n    "),a("span",{staticClass:"hljs-attr"},[t._v("state")]),t._v(": {\n        "),a("span",{staticClass:"hljs-attr"},[t._v("count")]),t._v(": "),a("span",{staticClass:"hljs-number"},[t._v("1")]),t._v("\n    },\n    "),a("span",{staticClass:"hljs-attr"},[t._v("mutations")]),t._v(": {\n        increment (state) {\n            "),a("span",{staticClass:"hljs-comment"},[t._v("// 变更状态")]),t._v("\n            state.count++\n        }   \n    }\n})\n\n")])]),t._v(" "),a("h4",[t._v("2.2.4 Actions")]),t._v(" "),a("p",[t._v("Action 类似于 mutation，不同在于：")]),t._v(" "),a("ul",[a("li",[t._v("Action 提交的是 mutation，而不是直接变更状态。")]),t._v(" "),a("li",[t._v("Action 可以包含任意异步操作。")])]),t._v(" "),a("p",[t._v("让我们来注册一个简单的 action：")]),t._v(" "),a("pre",[a("code",{staticClass:"language-javascript"},[a("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" store = "),a("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" Vuex.Store({\n\t"),a("span",{staticClass:"hljs-attr"},[t._v("state")]),t._v(": {\n\t\t"),a("span",{staticClass:"hljs-attr"},[t._v("count")]),t._v(": "),a("span",{staticClass:"hljs-number"},[t._v("0")]),t._v("\n\t},\n\t"),a("span",{staticClass:"hljs-attr"},[t._v("mutations")]),t._v(": {\n\t\tincrement(state) {\n\t\t\tstate.count++\n\t\t}\n\t},\n\t"),a("span",{staticClass:"hljs-attr"},[t._v("actions")]),t._v(": {\n\t\tincrement(context) {\n\t\t\tcontext.commit("),a("span",{staticClass:"hljs-string"},[t._v("'increment'")]),t._v(")\n\t\t}\n\t}\n})\n")])]),t._v(" "),a("p",[t._v("  Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 "),a("code",[t._v("context.commit")]),t._v(" 提交一个 mutation，或者通过 "),a("code",[t._v("context.state")]),t._v(" 和 "),a("code",[t._v("context.getters")]),t._v(" 来获取 state 和 getters。")]),t._v(" "),a("h4",[t._v("2.2.5 Modules")]),t._v(" "),a("p",[t._v("  使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。")]),t._v(" "),a("p",[t._v("  为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：")]),t._v(" "),a("pre",[a("code",{staticClass:"language-javascript"},[a("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" moduleA = {\n    "),a("span",{staticClass:"hljs-attr"},[t._v("state")]),t._v(": { ... },\n    "),a("span",{staticClass:"hljs-attr"},[t._v("mutations")]),t._v(": { ... },\n    "),a("span",{staticClass:"hljs-attr"},[t._v("actions")]),t._v(": { ... },\n    "),a("span",{staticClass:"hljs-attr"},[t._v("getters")]),t._v(": { ... }\n}\n\n"),a("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" moduleB = {\n"),a("span",{staticClass:"hljs-attr"},[t._v("state")]),t._v(": { ... },\n"),a("span",{staticClass:"hljs-attr"},[t._v("mutations")]),t._v(": { ... },\n"),a("span",{staticClass:"hljs-attr"},[t._v("actions")]),t._v(": { ... }\n}\n\n"),a("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" store = "),a("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" Vuex.Store({\n  "),a("span",{staticClass:"hljs-attr"},[t._v("modules")]),t._v(": {\n    "),a("span",{staticClass:"hljs-attr"},[t._v("a")]),t._v(": moduleA,\n    "),a("span",{staticClass:"hljs-attr"},[t._v("b")]),t._v(": moduleB\n  }\n})\n\nstore.state.a "),a("span",{staticClass:"hljs-comment"},[t._v("// -> moduleA 的状态")]),t._v("\nstore.state.b "),a("span",{staticClass:"hljs-comment"},[t._v("// -> moduleB 的状态")]),t._v("\n")])]),t._v(" "),a("h4",[t._v("2.3 官方文档")]),t._v(" "),a("p",[t._v("更多Vuex细节可以访问官方文档查看："),a("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/"}},[t._v("https://vuex.vuejs.org/zh-cn/")])]),t._v(" "),a("br"),t._v(" "),a("h3",[t._v("3.Vue-Router")]),t._v(" "),a("p",[t._v("  用 Vue.js + vue-router 创建单页应用，是非常简单的。使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。")]),t._v(" "),a("h4",[t._v("3.1 路由解析规则")]),t._v(" "),a("p",[t._v("  路由使用需要先定义好解析规则，用户访问路由时，根据解析规则定义的路径，访问到不同的页面或组件中，具体代码可以参考如下：")]),t._v(" "),a("pre",[a("code",{staticClass:"language-javascript"},[a("span",{staticClass:"hljs-keyword"},[t._v("export")]),t._v(" "),a("span",{staticClass:"hljs-keyword"},[t._v("default")]),t._v(" "),a("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" Router({\n    "),a("span",{staticClass:"hljs-attr"},[t._v("routes")]),t._v(": [\n        {\n            "),a("span",{staticClass:"hljs-attr"},[t._v("path")]),t._v(": "),a("span",{staticClass:"hljs-string"},[t._v("'/'")]),t._v(",\n            "),a("span",{staticClass:"hljs-attr"},[t._v("name")]),t._v(": "),a("span",{staticClass:"hljs-string"},[t._v("'index'")]),t._v(",\n            "),a("span",{staticClass:"hljs-attr"},[t._v("component")]),t._v(": "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-params"},[t._v("resolve")]),t._v(" =>")]),t._v(" "),a("span",{staticClass:"hljs-built_in"},[t._v("require")]),t._v("(["),a("span",{staticClass:"hljs-string"},[t._v("'../pages/Home.vue'")]),t._v("], resolve)\n        }\n    ]\n})\n")])]),t._v(" "),a("h4",[t._v("3.2 路由跳转")]),t._v(" "),a("p",[t._v("  定义好路由解析规则后，可以使用 "),a("strong",[t._v("导航式跳转")]),t._v(" 和 "),a("strong",[t._v("编程式跳转")]),t._v("，具体分别参考如下代码：")]),t._v(" "),a("pre",[a("code",{staticClass:"language-html"},[a("span",{staticClass:"hljs-tag"},[t._v("<"),a("span",{staticClass:"hljs-name"},[t._v("template")]),t._v(">")]),t._v('\n    .page\n        router-link(to="/index")Index\n'),a("span",{staticClass:"hljs-tag"},[t._v("</"),a("span",{staticClass:"hljs-name"},[t._v("template")]),t._v(">")]),t._v("\n")])]),t._v(" "),a("p",[t._v("  上面的是一个简单的路由导航式跳转，通过点击 "),a("code",[t._v("router-link")]),t._v(" 节点，会将路由定位到 "),a("code",[t._v("to")]),t._v(" 属性内的路径，从而实现单页应用的路由跳转功能，这种跳转方式简单方便，但往往不能满足复杂的交互逻辑，因此Vue-router也提供编程式跳转方式，具体参考如下代码：")]),t._v(" "),a("pre",[a("code",{staticClass:"language-javascript"},[t._v("<script>\n"),a("span",{staticClass:"hljs-keyword"},[t._v("export")]),t._v(" "),a("span",{staticClass:"hljs-keyword"},[t._v("default")]),t._v(" {\n    "),a("span",{staticClass:"hljs-attr"},[t._v("name")]),t._v(": "),a("span",{staticClass:"hljs-string"},[t._v("'example'")]),t._v(",\n    "),a("span",{staticClass:"hljs-attr"},[t._v("methods")]),t._v(": {\n        goHome() {\n            "),a("span",{staticClass:"hljs-keyword"},[t._v("this")]),t._v(".$router.push("),a("span",{staticClass:"hljs-string"},[t._v("'/index'")]),t._v(") "),a("span",{staticClass:"hljs-comment"},[t._v("//使用js操作路由跳转")]),t._v("\n        }\n    }\n}\n<"),a("span",{staticClass:"hljs-regexp"},[t._v("/script>\n")])])]),t._v(" "),a("p",[t._v("  通过路由的编程式跳转，基本可以满足所有情况下对路由的操作需求。通过这两种的路由跳转，我们可以完成大部分的路由开发工作。")]),t._v(" "),a("h4",[t._v("3.3 官方文档")]),t._v(" "),a("p",[t._v("更多Vue-router细节可以访问官方文档查看："),a("a",{attrs:{href:"https://router.vuejs.org/zh-cn/"}},[t._v("https://router.vuejs.org/zh-cn/")])])])}]}},80:function(t,s,a){t.exports=a(128)}});